<!DOCTYPE html>
<html lang="python">
<head>
<meta charset="utf-8"/>
<title>Applied Machine Learning</title>
<meta name="author" content="(Robert Utterback)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/reveal.js/3.0.0/css/reveal.css"/>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/reveal.js/3.0.0/css/theme/white.css" id="theme"/>

<link rel="stylesheet" href="./notes.css"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/reveal.js/3.0.0/lib/css/zenburn.css"/>
<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = 'https://cdn.jsdelivr.net/reveal.js/3.0.0/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
\(
\renewcommand{\vec}[1]{\boldsymbol{#1}}
\newcommand{\E}{\mathop{\boldsymbol{E}}}
\newcommand{\var}{\boldsymbol{Var}}
\newcommand{\norm}[1]{\lvert\lvert#1\rvert\rvert}
\newcommand{\abs}[1]{\lvert#1\rvert}
\newcommand{\ltwo}[1]{\norm{#1}_2}
\newcommand{\lone}[1]{\norm{#1}_1}
\newcommand{\sgn}[1]{\text{sign}\left( #1 \right)}
\newcommand{\e}{\mathrm{e}}
\newcommand{\minw}{\min_{w \in \mathbb{R}^p}}
\newcommand{\sumn}{\sum_{i=1}^n}
\newcommand{\logloss}{\log{(\exp{(-y_iw^T\vec{x}_i)} + 1)}}
\)

<section>
<section id="slide-org0e059b8">
<h2 id="org0e059b8">Linear Models for Classification</h2>
<p>
Robert Utterback
</p>

<p>
Based on slides by Andreas Muller
</p>
<aside class="notes">
<p>
Today we're going to talk about linear models for classification, and
in addition to that some general principles and advanced topics
surrounding general models, both for classification and regression.
</p>

</aside>
</section>
</section>
<section>
<section id="slide-org41860be">
<h2 id="org41860be">Linear models for <b>binary</b> classification</h2>
<aside class="notes">
<p>
We'll first start with linear models for binary classification, so if
there are only two classes. That makes the models much easier to
understand.
</p>

</aside>
</section>
<section id="slide-org7da83d3">
<h3 id="org7da83d3"></h3>
<p height="400px">
<img src="./assets/linear_boundary_vector.png" alt="linear_boundary_vector.png" height="400px" />
\[ \hat{y} = \sgn{w^T \vec{x} + b} = \sgn{\sum_i w_i x_i + b}\]
</p>
<aside class="notes">
<p>
Similar to the regression case, basically all linear models for classification have the same way to make predictions. As with regression, they compute an inner product of a weight vector w with the feature vector x, and add some bias b. The result of that is a real number, as in regression. For classification, however, we only look at the sign of the result, so whether it is negative or positive. If it's positive, we predict one class, usually called +1, if it's negative, we predict the other class, usually called -1. If the result is 0, by convention the positive class is predicted, but because it's a floating point number that doesn't really happen in practice. You'll see that sometimes in my notation I will not have a b. That's because you can always add a constant feature to x to achieve the same effect (thought you would then need to leave that feature out of the regularization). So when I write wTx without a b assume that there is a constant feature added that is not part of any regularization.
</p>

<p>
Geometrially, what the formula means is that the decision boundary of a linear classifier will be a hyperplane in the feature space, where w is the normal vector of that plane. In the 2d example here, it's just a line separating red and blue. Everything on the right hand side would be classified as blue by this classifier, and everything on the left-hand side as red.
</p>

<p>
Questions? So again, the learning here consists of finding parameters w and b based on the training set, and that is where the different algorithms differ. There are quite a lot of algorithms out there, and there are also quite a lot in scikit-learn, but we'll only discuss the most common ones.
</p>

<p>
The most straight-forward way to approach finding w and b is to use
the framework of empirical risk minimization that we talked about last
time, so finding parameters that minimize some loss o the training
set. Where classification differs quite a bit from regression is on
how we want to measure misclassifications.
</p>

</aside>
</section>
<section id="slide-org3acff4d">
<h3 id="org3acff4d">Loss Functions</h3>
<p>
\[ \hat{y} = \sgn{w^T\vec{x} + b}\]
\[ \min_{w \in \mathbb{R}^p} \sum_{i=1}^n \mathbf{1}\{ y_i \ne \sgn{w^T\vec{x} + b} \} \]
</p>


<div class="figure">
<p><img src="./assets/binary_loss.png" alt="binary_loss.png" height="300px" />
</p>
</div>

<aside class="notes">
<p>
So we need to define a loss function for given w and b that tell us how well they fit the training set. Obvious Idea: Minimize number of misclassifications aka 0-1 loss but this loss is non-convex, not continuous and minimizing it is NP-hard. So we need to relax it, which basically means we want to find a convex upper bound for this loss. This is not done on the actual prediction, but on the inner product wTx, which is also called the decision function. So this graph here has the inner product on the x axis, and shows what the loss would be for class 1. The 0-1 loss is zero if the decision function is positive, and one if it's negative. Because a positive decision function means a positive predition, means correct classification in the case of y=1. A negative prediction means a wrong classification, which is penalized by the 0-1 loss with a loss of 1, i.e. one mistake.
</p>

<p>
The other losses we'll talk about are mostly the hinge loss and the log loss. You can see they are both upper bounds on the 0-1 loss but they are convex and continuous. Both of these losses care not only that you make a correct prediction, but also "how correct" your prediction is, i.e. how positive or negative your decision function is. We'll talk a bit more about the motivation of these two losses, starting with the logistic loss.
</p>

</aside>
</section>
<section id="slide-org9a16c0e">
<h3 id="org9a16c0e">Logistic Regression</h3>
<div class="column" style="float:left; width: 30%">
<font size=5>
<p>
\[ \log\left( \frac{p(y=1 | x)}{p(y=0 | x)} \right) = w^T \vec{x} \]
\[ p(y | \vec{x}) = \frac{1}{1 + \e^{-w^T\vec{x}}} \]
\[ \minw \sum_{i=1}^n \log{(\exp{(-y_iw^T\vec{x}_i)} + 1)} \]
\[ \hat{y} = \sgn{w^T\vec{x} + b} \]
</p>
</font>
</div>
<div class="column" style="float:left; width: 70%">

<div class="figure">
<p><img src="./assets/sigmoid1.png" alt="sigmoid1.png" height="300px" />
</p>
</div>
</div>
<aside class="notes">
<p>
Logistic regression is probably the most commonly used linear classifier, maybe the most commonly used classifier overall. The idea is to model the log-odds, which is log p(y=1|x) - log p(y=0|x) as a linear function, as shown here. Rearranging the formula, you get a model of p(y=1|x) as 1 over 1 + &#x2026; This function is called the logistic sigmoid, and is drawn to the right here. Basically it squashed the linear function wTx between 0 and 1, so that it can model a probability.
</p>

<p>
Given this equation for p(y|x), what we want to do is maximize the probability of the training set under this model. This approach is known as maximum likelihood. Basically you want to find w and b such that they assign maximum probability to the labels observed in the training data. You can rearrange that a bit and end up with this equation here, which contains the log-loss as seen on the last slide.
</p>

<p>
The prediction is the class with the higher probability. In the binary case, that's the same as asking whether the probability of class 1 is bigger or smaller than .5. And as you can see from the plot of the logistic sigmoid, the probability of the class +1 is greater than .5 exactly if the decision function wTx is greater than 0. So predicting the class with maximum probability is the same as predicting which side of the hyperplane given by w we are on.
</p>

<p>
Ok so this is logistic regression. We minimize this loss and get a w which defines a hyper plane. But if you think back to last time, this is only part of what we want. This formulation tries to fit the training data, but it doesn't care about finding a simple solution.
</p>

</aside>
</section>
<section id="slide-org33eb7a1">
<h3 id="org33eb7a1">Penalized Logistic Regression</h3>
<p>
\[ \minw C \sumn \logloss + \ltwo{w}^2 \]
\[ \minw C \sumn \logloss + \lone{w} \]
</p>
<aside class="notes">
<p>
So we can do the same we did for regression: we can add regularization terms using the L1 and L2 norm. The effects are the same as for regression: both push the coefficients towards zero, but the l1 norm encourages coefficients to be exactly zero, for the same reasons we discussed last time.
</p>

<p>
You could also use a mixed penalty to get something like the elasticnet. That's not implemented in the logisticregression class in scikit-learn right now, but it's certainly a sensible thing to do.
</p>

<p>
But here is a different notation: C vs. alpha. Q: How doe they relate?
</p>

</aside>
</section>
<section id="slide-orgd5051f1">
<h3 id="orgd5051f1">Penalized Logistic Regression</h3>
<p>
\[ \minw C \sumn \logloss + \ltwo{w}^2 \]
\[ \minw C \sumn \logloss + \lone{w} \]
</p>

<ul>
<li>\(C\) is inverse to \(\alpha\) (or \(\frac{\alpha}{n}\))</li>
<li>Both versions strongly convex, l2 version smooth (differentiable).</li>
<li>All points contribute to w</li>

</ul>

<aside class="notes">
<p>
Here I used a slightly different notation as last time, though. I'm not using alpha to multiply the regularizer, instead I'm using C to multiply the loss. That's mostly because that's how it's done in scikit-learn and it has only historic reasons. The idea is exactly the same, only now C is 1 over alpha. So large C means heavy weight to the loss, means little regularization, while small C means less weight on the loss, means strong regularization.
</p>

<p>
Depending on the model, there might be a factor of n<sub>samples</sub> in there somewhere. Usually we try to make the objective as independent of the number of samples as possible in scikit-learn, but that might lead to surprises if you're not aware of it.
</p>

<p>
Some side-notes on the optimization problem: here, as in regression, having more regularization makes the optimization problem easier. You might have seen this in your homework already, if you decrease C, meaning you add more regularization, your model fits more quickly.
</p>

<p>
One particular property of the logistic loss, compared to the hinge loss we'll discuss next is that each data point contributes to the loss, so each data point has an effect on the solution. That's also true for all the regression models we saw last time.
</p>

</aside>
</section>
<section id="slide-orgd63142c">
<h3 id="orgd63142c">Linear SVM</h3>
<p>
\[ \minw C \sumn \max(0, 1-y_i w^T \vec{x}_i) + \ltwo{w}^2 \]
\[ \minw C \sumn \max(0, 1-y_i w^T \vec{x}_i) + \lone{w} \]
</p>

<ul>
<li>Both versions strongly convex, neither smooth.</li>
<li>Only some points contribute (the support vectors) to \(w\) ("sparse"
solution to dual)</li>

</ul>
<aside class="notes">
<p>
Moving from logistic regression to linear SVMs is just a matter of changing the loss from the log loss to the hinge loss. The hinge-loss is defined as &#x2026; And we can penalize using either l1 or l2 norm, or again, in principle also elastic net. This formulation with the hinge loss doesn't really make sense without the penalty, because of the formulation of the hinge loss. What this loss says is basically "if you predict the right class with a margin of 1, there is no loss". Otherwise the loss is linear in the decision function. So you need to be on the right side of the hyperplane by a given amount, and then there is no more loss. That's the reason you need the penalty, for the 1 to make sense. Otherwise you could just scale up w to make it far enough on the right side. But the regularization penalizes growing w.
</p>

<p>
The hinge loss has a kink, same as the l1 norm, and so it's not a smooth optimization problem any more, but that's not really a big deal. What's interesting is that all the points that are classified correctly with a margin of at least 1 have a loss of zero, and so they don't influence the solution any more. All the point that are not classified correctly by this margin are the ones that do influence the solution and they are called the support vectors.
</p>

</aside>
</section>
<section id="slide-org1dce0c9">
<h3 id="org1dce0c9">Logistic Regression vs. SVM</h3>
<p>
\[ \minw C \sumn \logloss + \ltwo{w}^2 \]
\[ \minw C \sumn \max(0, 1-y_i w^T \vec{x}_i) + \ltwo{w}^2 \]
</p>


<div class="figure">
<p><img src="./assets/binary_loss_classification.png" alt="binary_loss_classification.png" height="300px" />
</p>
</div>
<aside class="notes">
<p>
So this is the main difference between logistic regression and linear SVMs: Does it penalize misclassifications according to the green line, or according to the blue line? In practice it doesn't make a big difference.
</p>

</aside>
</section>
<section id="slide-org16878b5">
<h3 id="org16878b5">When to Use</h3>

<div class="figure">
<p><img src="./assets/svm_or_lr.png" alt="svm_or_lr.png" />
</p>
</div>
<ul>
<li>Need compact model or believe solution is sparse? Use l1.</li>

</ul>
<aside class="notes">
<p>
So which one of them should you use? If you need probability estimates, you should use logistic regression. If you don't, you can pick either, and it doesn't really matter. Logistic regression can be a bit faster to optimize in theory. If you're in a setting where there's many more feature than samples, it might make sense to use linear SVMs and solve the dual, but you can actually solve either of the problems in the dual, and we'll talk about what that means in practice in a little bit.
</p>

</aside>
</section>
<section id="slide-orgec560ee">
<h3 id="orgec560ee">Effect of Regularization</h3>

<div class="figure">
<p><img src="./assets/linear_svm_regularization.png" alt="linear_svm_regularization.png" />
</p>
</div>
<ul>
<li>Small \(C\) (lots of regularization) limits the influence of individual points!</li>

</ul>
<aside class="notes">
<p>
So I spared you with coefficient plots, because they looks the same as for regression. All the things I said about model complexity and dependency on the number of features and samples is as true for classification as it is for regression.
</p>

<p>
There is another interesting way to thing about regularization that I found helpful, though. I'm not going to walk through the math for this, but you can reformulate the optimization problem and find that what the C parameter does is actually limit the influence of individual data points. With very large C, we said we have no regularization. It also means individual data points can have basically unlimited influence, as you can see here. There are two outliers here, which basically completely tilt the decision boundary. But if we decrease C, and therefore increase the regularization, what happens is that the influence of these outlier points becomes limited, and the other points get more influence.
</p>

</aside>
</section>
</section>
</div>
</div>
<script src="https://cdn.jsdelivr.net/reveal.js/3.0.0/lib/js/head.min.js"></script>
<script src="https://cdn.jsdelivr.net/reveal.js/3.0.0/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
overview: true,
margin: 0.05,
minScale: 0.20,
maxScale: 15.00,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: '0.0',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: 'https://cdn.jsdelivr.net/reveal.js/3.0.0/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: 'https://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'https://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: 'https://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
 { src: 'https://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: 'https://cdn.jsdelivr.net/reveal.js/3.0.0/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
,pdfSeparateFragments: false});
</script>
</body>
</html>
